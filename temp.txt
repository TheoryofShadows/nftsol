
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { Request, Response, NextFunction } from 'express';
const JWT_SECRET = process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex');
const JWT_EXPIRES_IN = '24h';

export interface AuthRequest extends Request {
  user?: {
    id: string;
    walletAddress: string;
    role: string;
  };
}

// Hash password
export const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 12;
  return bcrypt.hash(password, saltRounds);
};

// Verify password
export const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};

// Generate JWT token
export const generateToken = (payload: object): string => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
};

// Verify JWT token
export const verifyToken = (token: string): any => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Authentication middleware
export const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    console.warn(`[AUTH] Invalid token attempt from IP: ${req.ip}`);
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};

// Admin role middleware
export const requireAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (!req.user || req.user.role !== 'admin') {
    console.warn(`[AUTH] Unauthorized admin access attempt from IP: ${req.ip}, User: ${req.user?.id}`);
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
};

// Generate secure session ID
export const generateSessionId = (): string => {
  return crypto.randomBytes(32).toString('hex');
};

// Encrypt sensitive data
export const encryptData = (data: string): { encrypted: string; iv: string } => {
  const algorithm = 'aes-256-cbc';
  const key = crypto.createHash('sha256').update(JWT_SECRET).digest();
  const iv = crypto.randomBytes(16);
  
  const cipher = crypto.createCipher(algorithm, key);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  return {
    encrypted,
    iv: iv.toString('hex')
  };
};

// Decrypt sensitive data
export const decryptData = (encryptedData: string, ivHex: string): string => {
  const algorithm = 'aes-256-cbc';
  const key = crypto.createHash('sha256').update(JWT_SECRET).digest();
  const iv = Buffer.from(ivHex, 'hex');
  
  const decipher = crypto.createDecipher(algorithm, key);
  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};

// Wallet address validation
export const validateSolanaAddress = (address: string): boolean => {
  const solanaAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
  return solanaAddressRegex.test(address);
};

// Transaction signature validation
export const validateSolanaSignature = (signature: string): boolean => {
  const signatureRegex = /^[1-9A-HJ-NP-Za-km-z]{87,88}$/;
  return signatureRegex.test(signature);
};

// Rate limiting for specific users
const userAttempts = new Map<string, { count: number; lastAttempt: number }>();

export const userSpecificRateLimit = (maxAttempts: number, windowMs: number) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    const userId = req.user?.id || req.ip;
    const now = Date.now();
    
    const userRecord = userAttempts.get(userId);
    
    if (!userRecord) {
      userAttempts.set(userId, { count: 1, lastAttempt: now });
      return next();
    }
    
    // Reset count if window has passed
    if (now - userRecord.lastAttempt > windowMs) {
      userAttempts.set(userId, { count: 1, lastAttempt: now });
      return next();
    }
    
    // Check if limit exceeded
    if (userRecord.count >= maxAttempts) {
      return res.status(429).json({ 
        error: 'Too many requests, please try again later' 
      });
    }
    
    // Increment count
    userRecord.count++;
    userRecord.lastAttempt = now;
    
    next();
  };
};

// Clean up old rate limit records periodically
setInterval(() => {
  const now = Date.now();
  for (const [userId, record] of userAttempts.entries()) {
    if (now - record.lastAttempt > 60 * 60 * 1000) { // 1 hour
      userAttempts.delete(userId);
    }
  }
}, 5 * 60 * 1000); // Clean up every 5 minutes



